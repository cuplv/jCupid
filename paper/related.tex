%% Attacks
Side-channel attacks are the class of attacks on cryptographic system that
attempt to gain information about a system by by exploiting involuntary
information leaks via physical properties---
such as temperature, electromagnetic leaks, memory footprints, and timing
delays---of the implementation rather than using brute force or exploiting
theoretical weakness of the algorithm.
Timing-based side-channel attacks are most common class of
side-channel attacks and are extremely powerful as physical isolation of the
server does not help and it is easier to observe the timing differentials than
temperature, memory, or electromagnetic leaks.  
Some notable examples of timing-based information leaks include \emph{padding oracle
attack}~\cite{Vau02}, \emph{Lucky-13 attack}~\cite{al2013lucky},  \emph{modular
exponentiator} employed in Diffie-Hellman, RSA, and DSS~\cite{kocher96}.

As an example of timing-based side-channel attack, consider modular
exponentiator used in Diffie-Hellman and RSA operations.
Here the system computes $R = y^x \mod n$ where $x$ is a secret key, $n$ is a
public information, and for an attacker it is easy to get hold of $y$.
In this attack the value $x$ of the secret key is fixed, and the attacker can
observe system response time for various combinations of $y$ and $n$.
A simple modular exponentiator algorithm is shown as Algorithm~\ref{alg:expo}.
Observe that in this algorithm a timing side-channel exists as depending upon
the value of the secret input, line $5$ may or may not be executed, and hence
algorithm will do different computation for different values of secret key, and
Kocher~\cite{kocher96} showed that it is sufficient to recover the secret key.
\begin{algorithm}[t]
Let $R = 1$\;
\For {$k = 0$ upto $w-1$}{
$R = R^2 \mod n$\;
\If {$x[k] = 1$}{
$R := (R \cdot y) \mod n$\;
}
}
\Return $R$\;
\caption{A Simple Modular Exponentiator Algorithm}
\label{alg:expo}
\end{algorithm}

A na\"ive remedy to timing-based information leaks in software-implemented
systems is to make the software run in fixed time for all possible inputs by
introducing timers to delay the observable outputs. 
However, it is quite difficult to ensure in practice, and even in the presence
of such timers CPU usage may also leak same information.
Transcript security model, proposed by Molnar et al.~\cite{Molnar05} is another way
to minimize information leak by requiring that for all confidential inputs, the
observable outputs (sequence of program counter values or opcodes) are
statistically indistinguishable.
Molnar et al.~\cite{Molnar05} present a run-time profiler for C programs to
detect side-channels by reporting pair of inputs that differ in program-counter
transcripts.  
In our work, we propose a similar runtime profiler to test whether a given
Java program is transcript secure where transcripts are Java Bytecode
instructions for inputs of same size.
Our framework, with some efforts, can be extended to more general notions of
transcripts. 

Fuzz testing~\cite{God12} is a scalable and effective techniques for finding security
vulnerability in software.
Fuzz testing techniques can naturally be partitioned into blackbox fuzz testing 
and whitebox fuzz-testing. 
In blackbox fuzz-testing approach well-formed inputs are randomly modified,
while conforming to a template given as formal grammar and probabilistic
weights, to generate other potentially interesting inputs.  
Some popular tools for blackbox fuzzing include Peach 
(\url{http://www.peachfuzzer.com/}) and Autodafe
(\url{http://autodafe.sourceforge.net/}).
In contrast, whitebox fuzzing techniques---introduced by Godefroid et
al.~\cite{God12,GKS05}---exploit symbolic execution and dynamic test-case generation
to systematically generate test-cases to exercise different control-paths by
negating conditions exercised by previous test-cases.
CUTE and jCUTE~\cite{Sen2006} are popular whitebox fuzzing tools for C and Java
programs. 
The run-time profiling framework that we propose in this paper can be
effectively used with both blackbox and whitebox fuzz testing techniques to
generate set of interesting inputs.



Synthesis of masking countermeasures against side-channel attacks~\cite{EW14}
secure information flow~\cite{Den76}, TaintDroid~\cite{Enck14}, Dynamic and
Static Information Flow~\cite{SR10}.
quantitative information flow~\cite{smith09}


%% \subsection{Old Part}
%% The idea monitoring executed bytecodes is not dissimilar to that of finding all
%% of the paths through a program. This led us to many concolic testers and input
%% fuzzers.  

%% In particular jFuzz~\cite{jayaraman2009jfuzz}, a concolic whitebox input fuzzer,
%% built on the NASA Java PathFinder. The goal of jFuzz is to start from a given
%% seed and using this find inputs which lead down all possible paths of a given
%% program. As mentioned this goal is not completely perpendicular to our own, and
%% finding which inputs lead down unique paths is valuable information. This
%% project however was difficult to get running, as it requires Java 1.5, and
%% seemingly does not work with Java 1.8. 

%% Additionally another concolic tester, jCute~\cite{conf/cav/SenA06} allowed us to
%% use more recent versions of Java. While jCute was a promising tool we found that
%% that for some of our test programs jCute did not recognize various paths in our
%% program. 

