%% Attacks
Side-channel attacks are the class of attacks on cryptographic system that
attempt to gain information about a system by by exploiting involuntary
information leaks via physical properties---
such as temperature, electromagnetic leaks, memory footprints, and timing
delays---of the implementation rather than using brute force or exploiting
theoretical weakness of the algorithm.
For our tool we focus on timing based information leaks in systems
implemented in software. 
Some notable examples of timing-based information leaks include \emph{padding oracle
attack}~\cite{Vau02}, \emph{Lucky-13 attack}~\cite{al2013lucky},  Modular
exponentiation algorithm employed in Diffie-Hellman, RSA, and
DSS~\cite{kocher96}.

A na\"ive remedy to timing-based information leaks in software-implemented
systems is to make the software run in fixed time for all possible inputs by
introducing timers to delay the observable outputs. 
However, it is quite difficult to ensure in practice, and moreover the often CPU
usage may also leak information in this situation. 
Transcript security model by Molnar et al.~\cite{Molnar05} is another way
to minimize information leak by requiring that for all confidential inputs, the
observable outputs (sequence of program counter values or opcodes) are
statistically indistinguishable.
Molnar et al.~\cite{Molnar05} present a run-time profiler for C programs to
detect side-channels by reporting pair of inputs that differ in program-counter
transcripts.  
In our work, we propose a similar runtime profiler to test whether a given
Java program is transcript secure where transcripts are Java Bytecode
instructions for inputs of same size.
Our framework, with some efforts, can be extended to more general notions of
transcripts. 

Fuzz testing~\cite{God12} is a scalable and effective techniques for finding security
vulnerability in software.
Fuzz testing techniques can naturally be partitioned into blackbox fuzz testing 
and whitebox fuzz-testing. 
In blackbox fuzz-testing approach well-formed inputs are randomly modified,
while conforming to a template given as formal grammar and probabilistic
weights, to generate other potentially interesting inputs.  
Some popular tools for blackbox fuzzing include Peach 
(\url{http://www.peachfuzzer.com/}) and Autodafe
(\url{http://autodafe.sourceforge.net/}).
In contrast, whitebox fuzzing techniques---introduced by Godefroid et
al.~\cite{God12,GKS05}---exploit symbolic execution and dynamic test-case generation
to systematically generate test-cases to exercise different control-paths by
negating conditions exercised by previous test-cases.
CUTE and jCUTE~\cite{Sen2006} are popular whitebox fuzzing tools for C and Java
programs. 
The run-time profiling framework that we propose in this paper can be
effectively used with both blackbox and whitebox fuzz testing techniques to
generate set of interesting inputs.



Synthesis of masking countermeasures against side-channel attacks~\cite{EW14}
secure information flow~\cite{Den76}, TaintDroid~\cite{Enck14}, Dynamic and
Static Information Flow~\cite{SR10}.
quantitative information flow~\cite{smith09}


%% \subsection{Old Part}
%% The idea monitoring executed bytecodes is not dissimilar to that of finding all
%% of the paths through a program. This led us to many concolic testers and input
%% fuzzers.  

%% In particular jFuzz~\cite{jayaraman2009jfuzz}, a concolic whitebox input fuzzer,
%% built on the NASA Java PathFinder. The goal of jFuzz is to start from a given
%% seed and using this find inputs which lead down all possible paths of a given
%% program. As mentioned this goal is not completely perpendicular to our own, and
%% finding which inputs lead down unique paths is valuable information. This
%% project however was difficult to get running, as it requires Java 1.5, and
%% seemingly does not work with Java 1.8. 

%% Additionally another concolic tester, jCute~\cite{conf/cav/SenA06} allowed us to
%% use more recent versions of Java. While jCute was a promising tool we found that
%% that for some of our test programs jCute did not recognize various paths in our
%% program. 

